#BlueJ class context
comment0.params=
comment0.target=Heap()
comment0.text=\r\n\ Crea\ un\ Heap\ vacio,\ orientado\ a\ la\ obtencion\ rapida\ del\ menor\ de\ n\ \r\n\ elementos\ (un\ heap\ ascendente\:\ el\ menor\ en\ la\ raiz).\r\n
comment1.params=n
comment1.target=Heap(int)
comment1.text=\r\n\ Crea\ un\ Heap\ vacio,\ con\ capacidad\ inicial\ para\ n\ componentes,\ orientado\ a\ \r\n\ la\ obtencion\ rapida\ del\ menor\ de\ esos\ elementos\ (un\ heap\ ascendente\:\ el\ menor\ \r\n\ en\ la\ raiz).\r\n\ @param\ n\ la\ capacidad\ inicial\ del\ heap.\r\n
comment10.params=
comment10.target=java.lang.String\ toString()
comment10.text=\r\n\ Retorna\ una\ cadena\ con\ la\ conversion\ a\ String\ del\ Heap,\ en\ orden\ \ \r\n\ lineal\ tal\ como\ figuran\ los\ elementos\ en\ el\ arreglo\ de\ soporte.\r\n\ @return\ la\ conversion\ a\ String\ de\ la\ Heap.\r\n
comment11.params=
comment11.target=boolean\ isAscendent()
comment11.text=\r\n\ Retorna\ el\ tipo\ de\ Heap\:\ true\ si\ es\ ascendente,\ false\ si\ es\ descendente.\r\n\ @return\ true\:\ el\ heap\ es\ ascendente\ -\ false\:\ es\ descendente.\r\n
comment12.params=nc
comment12.target=void\ adjustCapacity(int)
comment12.text=\r\n\ Ajusta\ la\ capacidad\ del\ arreglo\ al\ nuevo\ valor\ nc.\ Este\ valor\ puede\ ser\r\n\ menor\ o\ mayor\ al\ anterior\ valor\ de\ capacidad.\ El\ metodo\ no\ controla\ si\ \r\n\ la\ operaci\u00F3n\ es\ valida\ para\ la\ cantidad\ de\ elementos\ en\ el\ heap\ original.\r\n
comment13.params=sl\ sr
comment13.target=boolean\ optimal_left(int,\ int)
comment13.text=\r\n\ Chequea\ dos\ elementos\ hermanos\ y\ retorna\ true\ si\ el\ optimo\ es\ el\ izquierdo,\ o\ false\ si\ es\r\n\ el\ derecho.\ Entendemos\ por\ "optimo"\ al\ menor\ de\ los\ dos\ si\ el\ heap\ es\ ascendente,\ o\ al\ mayor\r\n\ si\ el\ heap\ es\ descendente.\r\n
comment14.params=s\ f
comment14.target=boolean\ valid_change(int,\ int)
comment14.text=\r\n\ \ Retorna\ true\ el\ elemento\ en\ la\ posici\u00F3n\ s\ del\ heap\ deberia\ intercambiarse\ con\ el\r\n\ \ elemento\ en\ la\ posicion\ f\ del\ heap.\ Se\ supone\ que\ heap[s]\ es\ hijo\ (izquierdo\ o\ \r\n\ \ derecho)\ de\ heap[f],\ aunque\ el\ m\u00E9todo\ no\ valida\ ese\ supuesto.\ La\ comprobacion\ se\r\n\ \ realiza\ de\ acuerdo\ al\ tipo\ de\ heap\:\ si\ es\ un\ heap\ ascendente,\ se\ retornara\ true\ si\r\n\ \ heap[s]\ <\ heap[f],\ pero\ si\ el\ heap\ es\ descendente\ se\ retornara\ true\ si\ heap[s]\ >\ heap[f].\r\n
comment15.params=x
comment15.target=boolean\ isHomogeneus(java.lang.Comparable)
comment2.params=t
comment2.target=Heap(boolean)
comment2.text=\r\n\ Crea\ un\ Heap\ vacio,\ con\ capacidad\ inicial\ para\ 100\ componentes.\ El\ tipo\ de\ heap\ \r\n\ a\ crear\ depende\ del\ parametro\ t\:\ si\ t\ \=\ true,\ el\ heap\ ser\u00E1\ ascendente\ (orientado\ a\ la\ \r\n\ obtencion\ rapida\ del\ menor),\ si\ t\ \=\ false\ entonces\ sera\ descendente\ (orientado\ a\ \r\n\ la\ obtencion\ rapida\ del\ mayor)..\r\n\ @param\ t\ el\ tipo\ de\ heap\ a\ crear\ (true\:\ ascendente\ -\ false\:\ descendente)\r\n
comment3.params=n\ t
comment3.target=Heap(int,\ boolean)
comment3.text=\r\n\ Crea\ un\ Heap\ vacio,\ con\ capacidad\ inicial\ para\ n\ componentes.\ El\ tipo\ de\ heap\ a\ \r\n\ crear\ depende\ del\ parametro\ t\:\ si\ t\ \=\ true,\ el\ heap\ ser\u00E1\ ascendente\ (orientado\ a\ la\ \r\n\ obtencion\ rapida\ del\ menor),\ si\ t\ \=\ false\ entonces\ sera\ descendente\ (orientado\ a\ \r\n\ la\ obtencion\ rapida\ del\ mayor).\r\n\ @param\ n\ la\ capacidad\ inicial\ del\ heap.\r\n\ @param\ t\ el\ tipo\ de\ heap\ a\ crear\ (true\:\ ascendente\ -\ false\:\ descendente)\r\n
comment4.params=data
comment4.target=void\ add(java.lang.Comparable)
comment4.text=\r\n\ Inserta\ un\ nuevo\ objeto\ en\ el\ heap.\ Se\ admiten\ repeticiones.\ La\ insercion\ se\ realiza\r\n\ con\ tiempo\ de\ ejecucion\ de\ O(log(n)),\ siendo\ n\ la\ cantidad\ de\ elementos\ del\ heap.\r\n\ @param\ data\ el\ objeto\ a\ insertar.\r\n
comment5.params=
comment5.target=void\ clear()
comment5.text=\r\n\ Remueve\ todos\ los\ elementos\ del\ heap\ y\ lo\ deja\ vacio.\ La\ capacidad\ vuelve\r\n\ al\ valor\ default\ de\ 100.\ El\ tipo\ de\ heap\ (ascendente\ o\ descendente)\ se\ mantiene\r\n\ igual\ al\ que\ se\ tenia\ antes\ de\ invocar\ a\ clear.\ \ \r\n
comment6.params=
comment6.target=java.lang.Comparable\ get()
comment6.text=\r\n\ Retorna\ el\ elemento\ de\ la\ cima\ del\ Heap,\ sin\ removerlo.\ Si\ el\ Heap\r\n\ es\ de\ tipo\ ascendente,\ el\ objeto\ retornado\ sera\ el\ menor\ del\ heap,\r\n\ y\ si\ el\ heap\ es\ descendente,\ el\ objeto\ retornado\ sera\ el\ mayor.\ Si\ \r\n\ el\ heap\ esta\ vacio,\ retorna\ null;\r\n
comment7.params=
comment7.target=boolean\ isEmpty()
comment7.text=\r\n\ Permite\ determinar\ si\ el\ Heap\ esta\ vacio.\r\n\ @return\ true\ si\ el\ Heap\ esta\ vacio.\r\n
comment8.params=
comment8.target=java.lang.Comparable\ remove()
comment8.text=\r\n\ Obtiene\ y\ retorna\ el\ elemento\ de\ la\ cima\ del\ heap.\ Si\ el\ heap\ es\ de\ \r\n\ tipo\ ascendente,\ ese\ elemento\ sera\ el\ menor\ del\ heap.\ En\ caso\ contrario\ \r\n\ sera\ el\ mayor.\ Rearma\ el\ heap\ con\ los\ elementos\ restantes,\ de\ forma\ que\r\n\ luego\ de\ terminada\ la\ operacion,\ la\ cima\ vuelve\ a\ contener\ al\ menor\ (o\ al\r\n\ mayor)\ de\ los\ elementos\ que\ quedaban,\ y\ la\ cantidad\ de\ elementos\ se\ reduce\r\n\ en\ uno.\ Si\ el\ heap\ esta\ vacio,\ retorna\ null.\ Tiempo\ de\ ejecuci\u00F3n\ esperado\r\n\ (en\ el\ peor\ caso)\:\ O(log(n)).\r\n\ @return\ el\ elemento\ menor\ (o\ el\ mayor)\ del\ heap.\r\n
comment9.params=
comment9.target=int\ size()
comment9.text=\r\n\ Retorna\ la\ cantidad\ de\ elementos\ contenidos\ en\ la\ SkipList.\r\n\ @return\ el\ tama\u00F1o\ de\ la\ SkipList.\r\n
numComments=16
